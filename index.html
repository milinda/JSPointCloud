<html>
<head>
    <title>JS Point Cloud</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
<script src="js/papaparse.min.js"></script>
<script src="js/three.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/randomColor.js"></script>
<script>
    if (!Detector.webgl) Detector.addGetWebGLMessage();
    var container, stats;
    var camera, scene, renderer;
    var mesh;
    var particleSystem;
    var colorMap = {};

    init();

    function init() {
        container = document.body;
        //
        camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 0.1, 5);
        camera.position.z = 5;
        scene = new THREE.Scene();
        //scene.fog = new THREE.Fog(0x050505, 9, 9);

        Papa.parse("data/AMF_Phylo_Seqs_599Nts_Apr17MAFFT_seqs_swgms_pid_1821_smacof_points_w_orig_pnum.csv", {
            download: true,
            complete: function(results) {

                var geometry = new THREE.BufferGeometry();

                console.log("Size:", results.data.length);

                var positions = new Float32Array(results.data.length * 3);
                var colors = new Float32Array(results.data.length * 3);

                for(var i in results.data){
                    var row = results.data[i];

                    var color;

                    if(row[4] in colorMap){
                        color = colorMap[row[4]];
                    } else {
                        color = new THREE.Color();
                        color.setRGB(Math.floor((Math.random() * 255) + 1), Math.floor((Math.random() * 255) + 1), Math.floor((Math.random() * 255) + 1));
                        colorMap[row[4]] = color;
                    }

                    positions[i] = row[1] * 10;
                    positions[i + 1] = row[2] * 10;
                    positions[i + 2] = row[3] * 10;

                    colors[ i ] = color.r;
                    colors[ i + 1 ] = color.g;
                    colors[ i + 2 ] = color.b;
                }

                geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.computeBoundingSphere();
                //
                var material = new THREE.PointCloudMaterial({ size: 0.02, vertexColors: true });
                particleSystem = new THREE.PointCloud(geometry, material);
                scene.add(particleSystem);
                //
                renderer = new THREE.WebGLRenderer({ antialias: true });
                //renderer.setClearColor(scene.fog.color, 1);
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);
                //
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild(stats.domElement);
                //
                window.addEventListener('resize', onWindowResize, false);

                console.log(colorMap);
                animate();
            }
        });
    }
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    //
    function animate() {
        requestAnimationFrame(animate);
        render();
        stats.update();
    }
    function render() {
//        var time = Date.now() * 0.001;
//        particleSystem.rotation.x = time * 0.25;
//        particleSystem.rotation.y = time * 0.5;
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
